{"mappings":"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","sources":["src/three-cube.js"],"sourcesContent":["import * as THREE from \"three\"\n\nconst DEFAULT_COLORS = [\"#B90000\", \"#ffffff\", \"#FFD500\", \"#FF5900\", \"#009B48\", \"#0045AD\"]\nconst SNAPPING_TIME = 200\nconst SPACING_FACTOR = 1.1\n\n/**\n * @typedef  CubeOptions\n * @type {object}\n * @property {THREE.Scene} scene\n * @property {HTMLCanvasElement} canvas\n * @property {THREE.Camera} camera\n * @property {number} x\n * @property {number} y\n * @property {number} z\n * @property {number} cubeSize\n * @property {THREE.Vector3} [position]\n * @property {(event?:PointerEvent)=>void} [onInteractStart] By default when mouse pointer starts \n * to rotate the cube, a pointerup event is dispatched on renderig element to prevent \n * any Control from rotating camera. This behaviour can be overridden by passing a \n * custom function which may do nothing if needed.\n * @property {(event?:PointerEvent)=>void} [onInteractEnd] Optional callback when user has finished \n * interacting with the cube.\n * @property {string[]} [colors] Optional hex color array of length 6\n * @property {number} [turnTime] Optional time taken to make one move in milliseconds. default is 200ms\n * @property {number} [snapTime] Optional time taken to snap in milliseconds. default is 200ms\n */\n\nconst AXES = /** @type {Array<\"x\"|\"y\"|\"z\">} */ ([\"x\", \"y\", \"z\"])\nconst STATES = {\n\tIDLE: 0,\n\tTURNING_CUBE: 1,\n\tAUTO_TURNING_CUBE: 2\n}\n\nexport class THREECube {\n\t/**\n\t * Creates an Grid arrangement of cubes in x, y and z axes. Logically the indexing of the layers\n\t * follows the negative axis of the direction in question. \n\t * \n\t * Ex: The layers in the x plane are indexed x0, x1, x2.. With x0 having the highest position x value\n\t * @param {CubeOptions} options \n\t */\n\tconstructor(options) {\n\t\tthis.scene = options.scene\n\t\tthis.cubeSize = options.cubeSize\n\t\tthis.cubes = /** @type {THREE.Object3D[]} */ ([])\n\t\tthis.layout = {\n\t\t\tx: options.x || 1,\n\t\t\ty: options.y || 1,\n\t\t\tz: options.z || 1\n\t\t}\n\t\tthis.turns = /** @type {string[]} */ ([])\n\t\tthis.state = STATES.IDLE\n\n\t\tconst rotationAxis = new THREE.Vector3(1, 1, 1)\n\t\t/** @type {THREE.Object3D} */\n\t\tlet referenceCube\n\t\tconst rotatingCubes = /** @type {THREE.Object3D[]} */ ([])\n\t\tlet directionCheck = false\n\t\tlet totalRotated = 0\n\n\t\tlet snapDelta = 0\n\t\tlet previousTime = 0\n\n\t\tconst canvas = options.canvas\n\t\tconst camera = options.camera\n\t\tconst scene = this.scene\n\t\tconst interactStart = options.onInteractStart || ((event) => {\n\t\t\t//this because we have no control over event handling of trackball controls\n\t\t\tcanvas.dispatchEvent(new PointerEvent(\"pointerup\", event))\n\t\t})\n\t\tconst interactEnd = options.onInteractEnd || (() => {})\n\t\tconst cubeSize = options.cubeSize\n\t\tconst gridMultiplier = cubeSize * SPACING_FACTOR\n\t\tconst _this = this\n\t\t/** @type {\"x\"|\"y\"|\"z\"} */\n\t\tlet fixedNormal\n\t\tconst previous3DPoint = new THREE.Vector3()\n\t\tconst differenceVector = new THREE.Vector3()\n\n\t\tconst mousePoint = new THREE.Vector2()\n\t\tconst previousMousePoint = new THREE.Vector2()\n\t\tconst directionVector = new THREE.Vector2()\n\t\tconst startMousePoint = new THREE.Vector2()\n\t\tconst worldNormal = new THREE.Vector3()\n\t\tthis.unbindHandlers = () => {}\n\t\tlet currentLayer = \"z0\"\n\t\tlet colorArray = DEFAULT_COLORS\n\t\tif (options.colors instanceof Array && options.colors.length == 6)\n\t\t\tcolorArray = options.colors\n\t\tthis.position = new THREE.Vector3(0, 0, 0)\n\t\tif (options.position instanceof THREE.Vector3)\n\t\t\tthis.position = options.position\n\n\t\tthis.turnTime = SNAPPING_TIME\n\t\tthis.snapTime = SNAPPING_TIME\n\t\tif (typeof options.turnTime == \"number\")\n\t\t\tthis.turnTime = Math.max(options.turnTime, 200)\n\t\tif (typeof options.snapTime == \"number\" && options.snapTime > 75)\n\t\t\tthis.snapTime = Math.max(options.snapTime, 100)\n\n\t\tfunction setBindings() {\n\t\t\t/**\n\t\t\t * @param {PointerEvent} event \n\t\t\t */\n\t\t\tfunction onCanvasMouseDown(event) {\n\t\t\t\tif (_this.state == STATES.AUTO_TURNING_CUBE)\n\t\t\t\t\treturn\n\n\t\t\t\t_this.state = STATES.IDLE\n\t\t\t\tif (snapDelta)\n\t\t\t\t\treturn\n\n\t\t\t\tmousePoint.x = event.pageX\n\t\t\t\tmousePoint.y = event.pageY\n\n\t\t\t\tconst vector2 = new THREE.Vector2((mousePoint.x / canvas.width) * 2 - 1, -(mousePoint.y / canvas.height) * 2 + 1)\n\t\t\t\tconst raycaster = new THREE.Raycaster()\n\t\t\t\traycaster.setFromCamera(vector2, camera)\n\t\t\t\tconst intersectionObject = raycaster.intersectObjects(scene.children)[0]\n\t\t\t\tif (intersectionObject) {\n\t\t\t\t\tconst foundCube = _this.cubes.find(cube => cube == intersectionObject.object)\n\t\t\t\t\tif (foundCube) {\n\t\t\t\t\t\tinteractStart(event)\n\t\t\t\t\t\t_this.state = STATES.TURNING_CUBE\n\t\t\t\t\t\treferenceCube = intersectionObject.object\n\t\t\t\t\t\tworldNormal.copy(intersectionObject.face.normal)\n\t\t\t\t\t\tworldNormal.transformDirection(referenceCube.matrixWorld)\n\t\t\t\t\t\tprevious3DPoint.copy(intersectionObject.point)\n\t\t\t\t\t\t//calculate what normal it is??\n\t\t\t\t\t\tif (Math.round(worldNormal.x))\n\t\t\t\t\t\t\tfixedNormal = \"x\"\n\t\t\t\t\t\telse if (Math.round(worldNormal.y))\n\t\t\t\t\t\t\tfixedNormal = \"y\"\n\t\t\t\t\t\telse if (Math.round(worldNormal.z))\n\t\t\t\t\t\t\tfixedNormal = \"z\"\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpreviousMousePoint.copy(mousePoint)\n\t\t\t\tstartMousePoint.copy(mousePoint)\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @param {PointerEvent} event \n\t\t\t */\n\t\t\tfunction onCanvasMouseMove(event) {\n\t\t\t\t//event.preventDefault()\n\t\t\t\tif (snapDelta)\n\t\t\t\t\treturn\n\n\t\t\t\tmousePoint.x = event.pageX\n\t\t\t\tmousePoint.y = event.pageY\n\n\n\t\t\t\tif (_this.state == STATES.TURNING_CUBE) {\n\t\t\t\t\tif (!directionCheck) {\n\t\t\t\t\t\tif (previousMousePoint.distanceToSquared(mousePoint) < 3)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\trotatingCubes.length = 0\n\n\t\t\t\t\t\tconst vector2 = new THREE.Vector2((mousePoint.x / canvas.width) * 2 - 1,\n\t\t\t\t\t\t\t-(mousePoint.y / canvas.height) * 2 + 1)\n\t\t\t\t\t\tconst raycaster = new THREE.Raycaster()\n\t\t\t\t\t\traycaster.setFromCamera(vector2, camera)\n\t\t\t\t\t\tconst intersectionObject = raycaster.intersectObjects(scene.children)[0]\n\t\t\t\t\t\tdifferenceVector.copy(intersectionObject.point).sub(previous3DPoint)\n\t\t\t\t\t\tconst x = Math.abs(differenceVector.x)\n\t\t\t\t\t\tconst y = Math.abs(differenceVector.y)\n\t\t\t\t\t\tconst z = Math.abs(differenceVector.z)\n\t\t\t\t\t\t/** @type {\"x\"|\"y\"|\"z\"} */\n\t\t\t\t\t\tlet rotationAbout = null\n\t\t\t\t\t\tif (fixedNormal == \"x\") {\n\t\t\t\t\t\t\trotationAbout = z > y ? \"y\" : \"z\"\n\t\t\t\t\t\t} else if (fixedNormal == \"y\") {\n\t\t\t\t\t\t\trotationAbout = x > z ? \"z\" : \"x\"\n\t\t\t\t\t\t} else if (fixedNormal == \"z\") {\n\t\t\t\t\t\t\trotationAbout = y > x ? \"x\" : \"y\"\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rotationAbout) {\n\t\t\t\t\t\t\tsetRotationAbout(rotationAbout)\n\t\t\t\t\t\t\tdirectionCheck = true\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst x = mousePoint.x - previousMousePoint.x\n\t\t\t\t\t\tconst y = mousePoint.y - previousMousePoint.y\n\t\t\t\t\t\tconst rotationAngle = ((x * directionVector.x) + (y * directionVector.y)) / 100\n\t\t\t\t\t\ttotalRotated += rotationAngle\n\t\t\t\t\t\trotatingCubes.forEach(c => rotateAroundWorldAxis(c, rotationAxis, rotationAngle, _this.position))\n\t\t\t\t\t}\n\t\t\t\t\tpreviousMousePoint.copy(mousePoint)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * \n\t\t\t * @param {PointerEvent} event \n\t\t\t */\n\t\t\tfunction onDocumentMouseUp(event) {\n\t\t\t\tif (_this.state === STATES.TURNING_CUBE) {\n\t\t\t\t\tinteractEnd(event)\n\t\t\t\t\tcommitTurn()\n\t\t\t\t}\n\t\t\t\tif (_this.state !== STATES.AUTO_TURNING_CUBE)\n\t\t\t\t\t_this.state = STATES.IDLE\n\t\t\t\tdirectionCheck = false\n\t\t\t\t//controls.enabled = true\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @param {\"x\"|\"y\"|\"z\"} axis \n\t\t\t */\n\t\t\tfunction setRotationAbout(axis) {\n\t\t\t\trotationAxis.set(0, 0, 0)\n\t\t\t\trotationAxis[axis] = 1\n\t\t\t\trotatingCubes.length = 0\n\t\t\t\tconst dividedPos = (referenceCube.position[axis] - _this.position[axis]) / gridMultiplier\n\t\t\t\tlet startPos = (options[axis] - 1) / 2\n\t\t\t\tlet index = startPos - dividedPos\n\t\t\t\tcurrentLayer = axis + index\n\t\t\t\tconst layerCubes = _this.getCubesInLayer(axis, index)\n\t\t\t\trotatingCubes.push(...layerCubes)\n\n\t\t\t\tconst otherAxis = AXES.find(oAxis => oAxis != axis && oAxis != fixedNormal)\n\t\t\t\tlet increment = worldNormal[fixedNormal] > 0 ? 2 : -2\n\t\t\t\tif (fixedNormal == \"z\" && axis == \"x\" ||\n\t\t\t\t\tfixedNormal == \"x\" && axis == \"y\" ||\n\t\t\t\t\tfixedNormal == \"y\" && axis == \"z\")\n\t\t\t\t\tincrement = -increment\n\t\t\t\tprevious3DPoint[otherAxis] += increment\n\t\t\t\tconst projection = previous3DPoint.project(camera)\n\t\t\t\tprojection.x = (projection.x + 1) / 2 * canvas.width\n\t\t\t\tprojection.y = -(projection.y - 1) / 2 * canvas.height\n\t\t\t\tdirectionVector.set(projection.x, projection.y).sub(startMousePoint)\n\t\t\t\tdirectionVector.normalize()\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Decides if a turn should happen. Also calculates a snap delta\n\t\t\t */\n\t\t\tfunction commitTurn() {\n\t\t\t\tlet anticlockwiseTurn = false\n\t\t\t\tlet doubleTurn = false\n\t\t\t\tconst direction = Math.sign(totalRotated)\n\t\t\t\ttotalRotated = Math.abs(totalRotated)\n\t\t\t\tlet slot = Math.floor(totalRotated / (Math.PI / 2)) * direction\n\t\t\t\tif (totalRotated % (Math.PI / 2) > Math.PI / 4)\n\t\t\t\t\tslot += 1 * direction\n\t\t\t\tconst otherAxes = AXES.filter(axis => !rotationAxis[axis])\n\t\t\t\tconst nonSymmetricRotation = options[otherAxes[0]] != options[otherAxes[1]]\n\t\t\t\tif (nonSymmetricRotation && (direction * slot % 2) == 1)\n\t\t\t\t\tslot += 1 * direction\n\t\t\t\tslot %= 4\n\n\t\t\t\t/**\n\t\t\t\t * Negative value of direction is a clockwise turn when looked at 0th layers of x,y and z\n\t\t\t\t */\n\t\t\t\tif (direction > 0)\n\t\t\t\t\tanticlockwiseTurn = true\n\n\t\t\t\tif (Math.abs(slot) == 3)\n\t\t\t\t\tanticlockwiseTurn = !anticlockwiseTurn\n\n\t\t\t\tif (Math.abs(slot) == 2) {\n\t\t\t\t\tdoubleTurn = true\n\t\t\t\t\tanticlockwiseTurn = false\n\t\t\t\t}\n\n\t\t\t\tsnapDelta = direction * (direction * slot * (Math.PI / 2) - totalRotated)\n\n\t\t\t\tif (slot) {\n\t\t\t\t\t_this.turns.push(currentLayer + (anticlockwiseTurn ? \"'\" : \"\"))\n\t\t\t\t\tif (doubleTurn)\n\t\t\t\t\t\t_this.turns.push(currentLayer)\n\t\t\t\t}\n\t\t\t\ttotalRotated = 0\n\t\t\t}\n\n\t\t\tcanvas.addEventListener(\"pointerdown\", onCanvasMouseDown)\n\t\t\tdocument.addEventListener(\"pointermove\", onCanvasMouseMove)\n\t\t\tdocument.addEventListener(\"pointerup\", onDocumentMouseUp)\n\n\t\t\t_this.unbindHandlers = function() {\n\t\t\t\tcanvas.removeEventListener(\"pointerdown\", onCanvasMouseDown)\n\t\t\t\tdocument.removeEventListener(\"pointermove\", onCanvasMouseMove)\n\t\t\t\tdocument.removeEventListener(\"pointerup\", onDocumentMouseUp)\n\t\t\t}\n\t\t}\n\n\t\tfunction createCubes() {\n\t\t\tlet indexedPosition = 0\n\t\t\tlet zPos = (options.z - 1) / 2\n\t\t\tconst id = Math.random()\n\t\t\tconst noColor = \"#000000\"\n\t\t\tfor (let z = 0; z < options.z; z++) {\n\t\t\t\tlet yPos = (options.y - 1) / 2\n\t\t\t\tfor (let y = 0; y < options.y; y++) {\n\t\t\t\t\tlet xPos = (options.x - 1) / 2\n\t\t\t\t\tfor (let x = 0; x < options.x; x++) {\n\t\t\t\t\t\tindexedPosition++\n\t\t\t\t\t\tconst faceColors = [\n\t\t\t\t\t\t\tx == 0 ? colorArray[3] : noColor,\n\t\t\t\t\t\t\tx + 1 == options.x ? colorArray[1] : noColor,\n\t\t\t\t\t\t\ty == 0 ? colorArray[5] : noColor,\n\t\t\t\t\t\t\ty + 1 == options.y ? colorArray[4] : noColor,\n\t\t\t\t\t\t\tz == 0 ? colorArray[2] : noColor,\n\t\t\t\t\t\t\tz + 1 == options.z ? colorArray[0] : noColor,\n\t\t\t\t\t\t]\n\n\t\t\t\t\t\tconst geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize)\n\t\t\t\t\t\tconst materials = /** @type {THREE.MeshPhongMaterial[]} */ ([])\n\t\t\t\t\t\tfaceColors.forEach(color => materials.push(new THREE.MeshPhongMaterial({ color: color })))\n\t\t\t\t\t\tconst cube = new THREE.Mesh(geometry, materials)\n\n\t\t\t\t\t\tcube.name = `CUBE_${id}_${indexedPosition}`\n\n\t\t\t\t\t\tcube.position.x = _this.position.x + (xPos * gridMultiplier)\n\t\t\t\t\t\tcube.position.y = _this.position.y + (yPos * gridMultiplier)\n\t\t\t\t\t\tcube.position.z = _this.position.z + (zPos * gridMultiplier)\n\n\t\t\t\t\t\tscene.add(cube)\n\t\t\t\t\t\t_this.cubes.push(cube)\n\n\t\t\t\t\t\txPos -= 1\n\t\t\t\t\t}\n\t\t\t\t\tyPos -= 1\n\t\t\t\t}\n\t\t\t\tzPos -= 1\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {number} timeStamp \n\t\t */\n\t\tfunction snap(timeStamp) {\n\t\t\tif (snapDelta) {\n\t\t\t\tlet delta = snapDelta * ((timeStamp - previousTime) / _this.snapTime)\n\t\t\t\tif (snapDelta < 0)\n\t\t\t\t\tdelta = Math.max(snapDelta - totalRotated, delta)\n\t\t\t\telse\n\t\t\t\t\tdelta = Math.min(snapDelta - totalRotated, delta)\n\t\t\t\trotatingCubes.forEach(c => rotateAroundWorldAxis(c, rotationAxis, delta, _this.position))\n\t\t\t\ttotalRotated += delta\n\t\t\t\tif (Math.abs(totalRotated - snapDelta) < 0.0001) {\n\t\t\t\t\ttotalRotated = 0\n\t\t\t\t\tsnapDelta = 0\n\t\t\t\t\tconst halfGridMultiplier = gridMultiplier / 2\n\t\t\t\t\trotatingCubes.forEach(cube => {\n\t\t\t\t\t\tcube.position.sub(_this.position)\n\t\t\t\t\t\tcube.position.x = Math.round((cube.position.x) / halfGridMultiplier) * halfGridMultiplier\n\t\t\t\t\t\tcube.position.y = Math.round((cube.position.y) / halfGridMultiplier) * halfGridMultiplier\n\t\t\t\t\t\tcube.position.z = Math.round((cube.position.z) / halfGridMultiplier) * halfGridMultiplier\n\t\t\t\t\t\tcube.position.add(_this.position)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {number} [timeStamp] \n\t\t */\n\t\tfunction perFrame(timeStamp) {\n\t\t\twindow.requestAnimationFrame(perFrame)\n\t\t\tsnap(timeStamp)\n\t\t\tpreviousTime = timeStamp\n\t\t}\n\n\t\tcreateCubes()\n\t\tsetBindings()\n\t\tperFrame()\n\t}\n\n\t/**\n\t * Removes all cubes from scene. Unbinds handlers.\n\t */\n\tdestroy() {\n\t\tthis.cubes.forEach(cube => this.scene.remove(cube))\n\t\tthis.unbindHandlers()\n\t}\n\n\t/**\n\t * Turns the arrangement passed number of times on randomly selected layers\n\t * with randomly selected direction\n\t * @param {number} count\n\t * @param {()=> void} [callback]\n\t */\n\tscramble(count, callback) {\n\t\tconst directions = /** @type {string[]} */ ([])\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst axis = AXES[Math.floor(Math.random() * 3)]\n\t\t\tconst layer = Math.floor(Math.random() * this.layout[axis])\n\t\t\tconst direction = Math.random() > 0.5 ? \"'\" : \"\"\n\t\t\tconst turnCode = `${axis}${layer}${direction}`\n\t\t\tif (turnCode + \"'\" === directions[i - 1] || turnCode === directions[i - 1] + \"'\") {\n\t\t\t\ti--\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdirections.push(`${axis}${layer}${direction}`)\n\t\t}\n\t\tconsole.log(directions)\n\t\tthis.turn(directions, callback)\n\t}\n\n\t/**\n\t * Rotates the arrangment on specific layers passed as an array of moves. \n\t * A single move is a combination of 3 characaters, ex: y1'. The first character denotes which\n\t * axis to rotate about. The second character is an integer to select a layer in that axis.\n\t * The third optional character denotes the direction of rotation. ' defines anticlockwise. \n\t * When this is absent the rotation is always clockwise.\n\t * @param {string[]} moves Example: [\"x0\", \"y1'\", \"y2\", \"x1\", z0]\n\t * @param {()=>void} callback\n\t */\n\tturn(moves, callback) {\n\t\tlet currentIndex = 0\n\t\tlet turnComplete = false\n\t\tlet previousTime = 0\n\t\tlet totalRotated = 0\n\t\tlet endRotation = Math.PI / 2\n\t\tconst cubesToRotate = /** @type {THREE.Object3D[]} */ ([])\n\t\tconst rotationAxis = new THREE.Vector3()\n\t\tlet rotationDirection = -1\n\t\tthis.state = STATES.AUTO_TURNING_CUBE\n\t\tconst _this = this\n\t\tconst halfGridMultiplier = this.cubeSize * SPACING_FACTOR / 2\n\n\t\t/**\n\t\t * @param {boolean} [dontAdd]\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction finishSingleMove(dontAdd) {\n\t\t\tif (!turnComplete)\n\t\t\t\treturn false\n\n\t\t\tif (!dontAdd)\n\t\t\t\t_this.turns.push(moves[currentIndex])\n\n\t\t\tcurrentIndex++\n\t\t\tif (currentIndex >= moves.length) {\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\tstartMove(currentIndex)\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\tfunction finishMoves() {\n\t\t\t_this.cubes.forEach(cube => {\n\t\t\t\tcube.position.sub(_this.position)\n\t\t\t\tcube.position.x = Math.round((cube.position.x) / halfGridMultiplier) * halfGridMultiplier\n\t\t\t\tcube.position.y = Math.round((cube.position.y) / halfGridMultiplier) * halfGridMultiplier\n\t\t\t\tcube.position.z = Math.round((cube.position.z) / halfGridMultiplier) * halfGridMultiplier\n\t\t\t\tcube.position.add(_this.position)\n\t\t\t})\n\t\t\t_this.state = STATES.IDLE\n\t\t\tcallback && callback()\n\t\t}\n\n\t\t/**\n\t\t * @param {number} index \n\t\t */\n\t\tfunction startMove(index) {\n\t\t\trotationAxis.set(0, 0, 0)\n\t\t\tconst layerAxis = /** @type {\"x\"|\"y\"|\"z\"} */ (moves[index][0])\n\t\t\tif (AXES.indexOf(layerAxis) === -1) {\n\t\t\t\tconsole.warn(\"Not a move! Skipping..\")\n\t\t\t\tfinishSingleMove(true)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trotationAxis[layerAxis] = 1\n\t\t\tconst layerIndex = parseInt(moves[index].substring(1))\n\t\t\tif (isNaN(layerIndex) || (layerIndex >= _this.layout[layerAxis] || layerIndex < 0)) {\n\t\t\t\tconsole.warn(\"Incorrect layer selected! Skipping..\")\n\t\t\t\tfinishSingleMove(true)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trotationDirection = (moves[index][moves[index].length - 1] == \"'\" ? 1 : -1)\n\t\t\tcubesToRotate.length = 0\n\t\t\tcubesToRotate.push(..._this.getCubesInLayer(layerAxis, layerIndex))\n\t\t\tturnComplete = false\n\t\t\ttotalRotated = 0\n\t\t\tconst otherAxes = AXES.filter(axis => !rotationAxis[axis])\n\t\t\tconst nonSymmetricRotation = _this.layout[otherAxes[0]] != _this.layout[otherAxes[1]]\n\t\t\tendRotation = Math.PI / 2\n\t\t\tif (nonSymmetricRotation)\n\t\t\t\tendRotation = Math.PI\n\t\t}\n\n\t\t/**\n\t\t * @param {number} timeStamp \n\t\t */\n\t\tfunction turnStep(timeStamp) {\n\t\t\tif (previousTime == 0)\n\t\t\t\tpreviousTime = timeStamp\n\t\t\tlet angleToRotate = (Math.PI / 2) * ((timeStamp - previousTime) / _this.turnTime)\n\t\t\tpreviousTime = timeStamp\n\t\t\ttotalRotated += angleToRotate\n\t\t\tif (totalRotated >= endRotation) {\n\t\t\t\tturnComplete = true\n\t\t\t\tangleToRotate -= totalRotated - endRotation\n\t\t\t}\n\t\t\tcubesToRotate.forEach(cube => rotateAroundWorldAxis(cube, rotationAxis, angleToRotate * rotationDirection, _this.position))\n\t\t\tif (!finishSingleMove()) {\n\t\t\t\twindow.requestAnimationFrame(turnStep)\n\t\t\t} else {\n\t\t\t\tfinishMoves()\n\t\t\t}\n\t\t}\n\t\tstartMove(currentIndex)\n\t\tturnStep(0)\n\t}\n\n\t/**\n\t * Returns all the cubes currently positioned in a particular axis and layer.\n\t * @param {\"x\"|\"y\"|\"z\"} axis \n\t * @param {number} index \n\t * @returns {Array<THREE.Object3D>}\n\t */\n\tgetCubesInLayer(axis, index) {\n\t\tlet startPos = (this.layout[axis] - 1) / 2\n\t\tconst position = ((startPos - index) * this.cubeSize * SPACING_FACTOR) + this.position[axis]\n\t\treturn this.cubes.filter(cube => Math.abs(cube.position[axis] - position) < 0.0000001)\n\t}\n\n\t/**\n\t * This applies only for a 3x3x3 arrangement.\n\t * @param {Array<string>|string} turns \n\t * @returns {Array<string>}\n\t */\n\tstatic SingmasterToCubeNotation(turns) {\n\t\tlet arrayTurns = (typeof turns == \"string\") ? turns.split(\" \") : turns\n\t\tconst cubeNotation = /** @type {string[]} */ ([])\n\t\tconst map = {\n\t\t\t\"R\": \"x0\",\n\t\t\t\"L\": \"x2'\",\n\t\t\t\"U\": \"y0\",\n\t\t\t\"D\": \"y2'\",\n\t\t\t\"F\": \"z0\",\n\t\t\t\"B\": \"z2'\"\n\t\t}\n\n\t\ttry {\n\t\t\tfor (let i = 0; i < arrayTurns.length; i++) {\n\t\t\t\tconst turn = arrayTurns[i]\n\t\t\t\tconst singTurn = /** @type {\"R\"|\"L\"|\"U\"|\"D\"|\"F\"|\"B\"} */\n\t\t\t\t\t(turn[0].toUpperCase())\n\t\t\t\tlet cubeTurn = map[singTurn]\n\t\t\t\tif (!cubeTurn)\n\t\t\t\t\tthrow new Error(\"Not a valid Singmaster notation.\")\n\n\t\t\t\tif (turn[turn.length - 1] === \"'\")\n\t\t\t\t\tcubeTurn += \"'\"\n\n\t\t\t\tcubeTurn = cubeTurn.replace(\"''\", \"\")\n\n\t\t\t\tcubeNotation.push(cubeTurn)\n\t\t\t\tif (turn[turn.length - 1] === \"2\")\n\t\t\t\t\tcubeNotation.push(cubeTurn)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t}\n\n\t\treturn cubeNotation\n\t}\n\n\t/**\n\t * Resets the arrangement to initial state. Sets the turns empty\n\t */\n\treset() {\n\t\tconst gridMultiplier = this.cubeSize * SPACING_FACTOR\n\t\tlet index = 0\n\t\tlet zPos = (this.layout.z - 1) / 2\n\t\tfor (let z = 0; z < this.layout.z; z++) {\n\t\t\tlet yPos = (this.layout.y - 1) / 2\n\t\t\tfor (let y = 0; y < this.layout.y; y++) {\n\t\t\t\tlet xPos = (this.layout.x - 1) / 2\n\t\t\t\tfor (let x = 0; x < this.layout.x; x++) {\n\t\t\t\t\tlet cube = this.cubes[index]\n\t\t\t\t\tcube.position.x = this.position.x + (xPos * gridMultiplier)\n\t\t\t\t\tcube.position.y = this.position.y + (yPos * gridMultiplier)\n\t\t\t\t\tcube.position.z = this.position.z + (zPos * gridMultiplier)\n\t\t\t\t\tcube.rotation.set(0, 0, 0)\n\t\t\t\t\tcube.quaternion.set(0, 0, 0, 1)\n\t\t\t\t\txPos -= 1\n\t\t\t\t\tindex++\n\t\t\t\t}\n\t\t\t\tyPos -= 1\n\t\t\t}\n\t\t\tzPos -= 1\n\t\t}\n\t\tthis.turns.length = 0\n\t}\n}\n\nconst matrixAux = new THREE.Matrix4() // global auxiliar variable\n/**\n * @param {THREE.Object3D} obj\n * @param {THREE.Vector3} axis\n * @param {number} radians\n * @param {THREE.Vector3} pivot\n */\nfunction rotateAroundWorldAxis(obj, axis, radians, pivot) {\n\tobj.position.sub(pivot)\n\tobj.updateMatrix()\n\tmatrixAux.makeRotationAxis(axis, radians)\n\tobj.matrix.multiplyMatrices(matrixAux, obj.matrix) // r56\n\tmatrixAux.extractRotation(obj.matrix)\n\tobj.rotation.setFromRotationMatrix(matrixAux, obj.rotation.order)\n\tobj.position.setFromMatrixPosition(obj.matrix)\n\tobj.position.add(pivot)\n}"],"names":[],"version":3,"file":"three-cube.module.js.map"}